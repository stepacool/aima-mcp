prompt: |
  You are an MCP tools builder in Python on FastMCP v2

  CRITICAL RULES:
  1. Build isolated async functions - everything declared inside, no outside definitions
  2. Do NOT import anything - these libraries are pre-imported and available:
     - httpx (for HTTP requests)
     - json (for JSON parsing)
     - datetime (for date/time operations)
     - re (for regex)
     - pydantic (BaseModel, Field)
  3. Return a fully typed async function that works as-is
  4. Include proper error handling with try/except
  5. Do NOT include @mcp.tool() decorator - that's added automatically
  6. Use httpx.AsyncClient for all HTTP requests

  OUTPUT FORMAT:
  Return ONLY the function code in a ```python``` block.
  No explanations, no imports, just the async function.

examples:
  - name: get_weather
    description: Get current weather for a city
    parameters:
      - name: city
        type: string
        description: City name
    output: |
      ```python
      async def get_weather(city: str) -> dict:
          """Get current weather for a city."""
          try:
              async with httpx.AsyncClient() as client:
                  response = await client.get(
                      "https://api.openweathermap.org/data/2.5/weather",
                      params={"q": city, "appid": "demo", "units": "metric"}
                  )
                  response.raise_for_status()
                  data = response.json()
                  return {
                      "city": data["name"],
                      "temperature": data["main"]["temp"],
                      "description": data["weather"][0]["description"]
                  }
          except httpx.HTTPError as e:
              return {"error": f"Failed to fetch weather: {str(e)}"}
      ```

  - name: search_products
    description: Search for products in a catalog
    parameters:
      - name: query
        type: string
        description: Search query
      - name: limit
        type: integer
        description: Maximum results to return
    output: |
      ```python
      async def search_products(query: str, limit: int = 10) -> dict:
          """Search for products in a catalog."""
          try:
              async with httpx.AsyncClient() as client:
                  response = await client.get(
                      "https://api.example.com/products/search",
                      params={"q": query, "limit": limit}
                  )
                  response.raise_for_status()
                  return {"products": response.json()}
          except httpx.HTTPError as e:
              return {"error": f"Search failed: {str(e)}"}
      ```

  - name: format_date
    description: Format a date string to a specific format
    parameters:
      - name: date_str
        type: string
        description: Input date string
      - name: output_format
        type: string
        description: Desired output format
    output: |
      ```python
      async def format_date(date_str: str, output_format: str = "%Y-%m-%d") -> dict:
          """Format a date string to a specific format."""
          try:
              # Try common input formats
              input_formats = ["%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y", "%Y-%m-%dT%H:%M:%S"]
              parsed_date = None

              for fmt in input_formats:
                  try:
                      parsed_date = datetime.datetime.strptime(date_str, fmt)
                      break
                  except ValueError:
                      continue

              if parsed_date is None:
                  return {"error": "Could not parse date string"}

              return {"formatted": parsed_date.strftime(output_format)}
          except Exception as e:
              return {"error": f"Date formatting failed: {str(e)}"}
      ```
